name: CI/CD Pipeline

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
      - 'plugin/**'
  pull_request:
    branches:
      - master
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  checks: write
  pull-requests: write

jobs:
  # ========================================
  # JOB 1: BUILD & TEST (sempre eseguito)
  # ========================================
  build-and-test:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v1.3

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v1.2.0

    - name: Restore NuGet packages
      run: nuget restore DO.VIVICARE.Reporting.sln

    - name: Build solution
      run: |
        msbuild DO.VIVICARE.Reporting.sln `
          /p:Configuration=Release `
          /p:Platform="Any CPU" `
          /maxcpucount
      shell: powershell

    - name: Run Unit Tests (optional)
      run: |
        $testProject = "DO.VIVICARE.Tests/DO.VIVICARE.Tests.csproj"
        if (Test-Path $testProject) {
          dotnet test $testProject `
            --configuration Release `
            --no-build `
            --logger "console;verbosity=detailed" `
            --logger "trx;LogFileName=test-results.trx"
        } else {
          Write-Host "Unit Test project not found, skipping..."
        }
      continue-on-error: true
      shell: powershell

    - name: Run Integration Tests (optional)
      run: |
        $testProject = "DO.VIVICARE.IntegrationTests/DO.VIVICARE.IntegrationTests.csproj"
        if (Test-Path $testProject) {
          dotnet test $testProject `
            --configuration Release `
            --no-build `
            --logger "console;verbosity=detailed" `
            --logger "trx;LogFileName=integration-test-results.trx"
        } else {
          Write-Host "Integration Test project not found, skipping..."
        }
      continue-on-error: true
      shell: powershell

    - name: Upload test results (if available)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: '**/test-results*.trx'
      continue-on-error: true

    - name: Publish test results (if available)
      if: always()
      uses: dorny/test-reporter@v1
      with:
        name: Test Results
        path: '**/test-results*.trx'
        reporter: 'dotnet-trx'
      continue-on-error: true

    # Upload build artifacts per i job successivi
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-output
        path: |
          **/bin/Release/**/*.dll
          **/bin/Release/**/*.exe
          **/bin/Release/**/*.pdb
        retention-days: 1

  # ========================================
  # JOB 2: RELEASE APP (solo se tag v*.*...*)
  # ========================================
  release-app:
    needs: build-and-test
    if: startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, 'plugin')
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-output

    - name: Extract version from tag
      id: version
      shell: powershell
      run: |
        $tag = "${{ github.ref }}"
        Write-Host "Processing tag: $tag"
        
        if ($tag -match "refs/tags/v(.*)$") {
          $version = $matches[1]
          Write-Host "Version extracted: $version"
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "tag=v$version" >> $env:GITHUB_OUTPUT
        } else {
          Write-Error "Invalid tag format"
          exit 1
        }

    - name: Import Code Signing Certificate
      shell: powershell
      run: |
        Write-Host "Importing code signing certificate..."
        
        try {
          $cert_base64 = "${{ secrets.CODESIGN_CERTIFICATE_BASE64 }}"
          if ([string]::IsNullOrEmpty($cert_base64)) {
            Write-Error "CODESIGN_CERTIFICATE_BASE64 secret not found"
            exit 1
          }
          
          $cert_bytes = [Convert]::FromBase64String($cert_base64)
          [IO.File]::WriteAllBytes("certificate.pfx", $cert_bytes)
          Write-Host "PFX file created"
          
          $password = "${{ secrets.CODESIGN_PASSWORD }}"
          if ([string]::IsNullOrEmpty($password)) {
            Write-Error "CODESIGN_PASSWORD secret not found"
            exit 1
          }
          
          $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force
          
          $cert = Import-PfxCertificate -FilePath "certificate.pfx" `
            -CertStoreLocation "Cert:\CurrentUser\My" `
            -Password $securePassword `
            -ErrorAction Stop
          
          Write-Host "Certificate imported successfully"
          Write-Host "Thumbprint: $($cert.Thumbprint)"
          Write-Host "Subject: $($cert.Subject)"
          
          echo "CERT_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_ENV
          
          Remove-Item "certificate.pfx" -Force
          Write-Host "Temporary certificate file removed"
        }
        catch {
          Write-Error "Error importing certificate: $_"
          exit 1
        }

    - name: Create Velopack Release Package
      shell: powershell
      run: |
        $version = "${{ steps.version.outputs.version }}"
        
        Write-Host "Creating Velopack release package..."
        
        try {
          $packageDir = "velopack-release"
          New-Item -ItemType Directory -Force -Path $packageDir | Out-Null
          Write-Host "Package directory created: $packageDir"
          
          $uiSource = "DO.VIVICARE.UI/bin/Release"
          if (Test-Path $uiSource) {
            Copy-Item "$uiSource/*" -Destination "$packageDir/" -Force -Recurse -ErrorAction Stop
            Write-Host "Copied UI binaries"
            
            if (-not (Test-Path "$packageDir/DO.VIVICARE.UI.exe")) {
              Write-Error "DO.VIVICARE.UI.exe not found after copy"
              exit 1
            }
            Write-Host "   • DO.VIVICARE.UI.exe"
          } else {
            Write-Error "UI binaries not found at: $uiSource"
            exit 1
          }
          
          $reporterSource = "DO.VIVICARE.Reporter/bin/Release"
          if (Test-Path $reporterSource) {
            Copy-Item "$reporterSource/*" -Destination "$packageDir/" -Force -Recurse -ErrorAction Stop
            Write-Host "Copied Reporter binaries"
            
            if (Test-Path "$packageDir/DO.VIVICARE.Reporter.dll") {
              Write-Host "   • DO.VIVICARE.Reporter.dll"
            }
          } else {
            Write-Warning "Reporter binaries not found at: $reporterSource (optional)"
          }
          
          Write-Host "`n Package contents:"
          Get-ChildItem -Path $packageDir -Recurse -File | ForEach-Object {
            Write-Host "   • $($_.Name)"
          }
          
          Write-Host "`n Release package created successfully"
        }
        catch {
          Write-Error "Error creating package: $_"
          exit 1
        }

    - name: Install Velopack CLI
      shell: powershell
      run: |
        Write-Host "Installing Velopack CLI..."
        
        try {
          dotnet tool install -g vpk
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Error installing Velopack CLI"
              exit 1
          }
          Write-Host "Velopack CLI installed"

          $toolsPath = [IO.Path]::Combine($env:USERPROFILE, ".dotnet", "tools")
          $env:PATH = "$toolsPath;$env:PATH"
          Write-Host "Tools path added to PATH: $toolsPath"
          
          $vpkHelp = & vpk --help 2>&1
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Velopack CLI installed successfully"
          } else {
            Write-Host "Velopack CLI installed but help command returned: $vpkHelp"
          }
        }
        catch {
          Write-Error "Error installing Velopack CLI: $_"
          exit 1
        }

    - name: Create Velopack Release (Pack & Sign)
      shell: powershell
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $certThumbprint = $env:CERT_THUMBPRINT
        
        Write-Host "Creating and signing Velopack release..."
        
        try {
          if ([string]::IsNullOrEmpty($certThumbprint)) {
            Write-Error "Certificate thumbprint not found"
            exit 1
          }
          
          Write-Host "Using certificate: $certThumbprint"
          
          New-Item -ItemType Directory -Force -Path "releases" | Out-Null
          
          $velopackCmd = @(
            "pack",
            "--packId", "DO.VIVICARE.Reporting",
            "--packVersion", "$version",
            "--packDir", "velopack-release",
            "--mainExe", "DO.VIVICARE.UI.exe",
            "--outputDir", "releases",
            "--signParams", "/fd sha256 /td sha256 /tr http://timestamp.digicert.com /sha1 $certThumbprint"
          )
          
          if (Test-Path "DO.VIVICARE.UI/DO-logo-2.ico") {
            $velopackCmd += @("--icon", "DO.VIVICARE.UI/DO-logo-2.ico")
            Write-Host "Using icon from DO.VIVICARE.UI/DO-logo-2.ico"
          } else {
            Write-Warning "Icon not found at DO.VIVICARE.UI/DO-logo-2.ico"
          }
          
          Write-Host "Executing: velopack $($velopackCmd -join ' ')"
          & vpk @velopackCmd
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Velopack pack failed with exit code: $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Velopack release created successfully"
          
          Write-Host "`n Generated files:"
          Get-ChildItem "releases" -Recurse -File | ForEach-Object {
            $size = [Math]::Round($_.Length / 1MB, 2)
            Write-Host "   • $($_.Name) ($size MB)"
          }
        }
        catch {
          Write-Error "Error creating Velopack release: $_"
          exit 1
        }

    - name: Generate Release Notes
      shell: powershell
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $now = Get-Date -Format "yyyy-MM-dd HH:mm"
        
        Write-Host "Generating release notes..."
        
        try {
          $releaseNotes = "# DO.VIVICARE Reporting v$version`n`n" +
            "**Release Date:** $now`n" +
            "**Packager:** Velopack (Code Signed)`n`n" +
            "## What's New`n`n" +
            "- Velopack integration (automatic updates and delta patching)`n" +
            "- Code-signed installer and binaries (SHA256)`n" +
            "- Configuration migrated to AppData (persistent across updates)`n`n" +
            "## Installation`n`n" +
            "1. Download the installer from the release assets`n" +
            "2. Run the installer`n" +
            "3. Start DO.VIVICARE Reporting`n`n" +
            "## Updates`n`n" +
            "- The app checks for updates automatically (interval configured in app.config)`n" +
            "- When an update is available, the user is notified and can install with one click`n"
          
          Set-Content -Path "RELEASE_NOTES_GENERATED.md" -Value $releaseNotes -Encoding UTF8
          Write-Host "Release notes generated: RELEASE_NOTES_GENERATED.md"
        }
        catch {
          Write-Error "Error generating release notes: $_"
          exit 1
        }
        
    - name: Upload Velopack Artifacts to Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          releases/**
          RELEASE_NOTES_GENERATED.md
        body_path: RELEASE_NOTES_GENERATED.md
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup Signing Certificate
      if: always()
      shell: powershell
      run: |
        Write-Host "Cleaning up signing certificate from certificate store..."
        
        try {
          $certs = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Subject -eq "CN=DO.VIVICARE.Reporting" }
          
          if ($certs) {
            foreach ($cert in $certs) {
              Remove-Item "Cert:\CurrentUser\My\$($cert.Thumbprint)" -Force -ErrorAction Stop
              Write-Host "Certificate removed: $($cert.Thumbprint)"
            }
          } else {
            Write-Host "No DO.VIVICARE.Reporting certificates found in store"
          }
        }
        catch {
          Write-Warning "Error during certificate cleanup: $_"
        }
        
        Write-Host "Cleanup completed"
        
  # ========================================
  # JOB 3: RELEASE PLUGIN (solo se tag plugin/*)
  # ========================================
  release-plugin:
    needs: build-and-test
    if: startsWith(github.ref, 'refs/tags/plugin/')
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-output

    - name: Extract plugin info from tag
      id: plugin
      shell: powershell
      run: |
        $tag = "${{ github.ref }}"
        Write-Host "Processing tag: $tag"
        
        # Format: refs/tags/plugin/{plugin-id}/{version}
        if ($tag -match "refs/tags/plugin/([^/]+)/([^/]+)$") {
          $pluginId = $matches[1]
          $version = $matches[2]
          
          Write-Host "Plugin ID: $pluginId"
          Write-Host "Version: $version"
          
          # Map plugin ID to project folder
          $projectMap = @{
            "document.adialtaintensita" = "DO.VIVICARE.Document.ADIAltaIntensita"
            "document.adibassaintensita" = "DO.VIVICARE.Document.ADIBassaIntensita"
            "document.asst" = "DO.VIVICARE.Document.ASST"
            "document.comuni" = "DO.VIVICARE.Document.Comuni"
            "document.laziohealthworker" = "DO.VIVICARE.Document.LazioHealthWorker"
            "document.minsan" = "DO.VIVICARE.Document.MinSan"
            "document.prestazioni" = "DO.VIVICARE.Document.Prestazioni"
            "document.prezzi" = "DO.VIVICARE.Document.Prezzi"
            "document.rendiconto" = "DO.VIVICARE.Document.Rendiconto"
            "document.report16" = "DO.VIVICARE.Document.Report16"
            "document.report18" = "DO.VIVICARE.Document.Report18"
            "document.valorizzazione" = "DO.VIVICARE.Document.Valorizzazione"
            "document.valorizzazioniadialta" = "DO.VIVICARE.Document.ValorizzazioniADIAlta"
            "document.zsdfatture" = "DO.VIVICARE.Document.ZSDFatture"
            "report.allegatoadi" = "DO.VIVICARE.Report.AllegatoADI"
            "report.dietetica" = "DO.VIVICARE.Report.Dietetica"
            "report.valorizzazione" = "DO.VIVICARE.Report.Valorizzazione"
          }
          
          $projectName = $projectMap[$pluginId]
          
          if (-not $projectName) {
            Write-Error "Unknown plugin ID: $pluginId"
            exit 1
          }
          
          Write-Host "Project Name: $projectName"
          
          echo "pluginId=$pluginId" >> $env:GITHUB_OUTPUT
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "projectName=$projectName" >> $env:GITHUB_OUTPUT
        } else {
          Write-Error "Invalid tag format: $tag"
          exit 1
        }

    - name: Package plugin DLL
      shell: powershell
      run: |
        $projectName = "${{ steps.plugin.outputs.projectName }}"
        $version = "${{ steps.plugin.outputs.version }}"
        $dllPath = "$projectName/bin/Release/$projectName.dll"
        $outputName = "$projectName-$version.dll"
        
        Write-Host "Looking for DLL at: $dllPath"
        
        if (Test-Path $dllPath) {
          Copy-Item $dllPath -Destination $outputName
          Write-Host "Package created: $outputName"
        } else {
          Write-Error "DLL not found at: $dllPath"
          Get-ChildItem "$projectName/bin" -Recurse | Select-Object FullName
          exit 1
        }

    - name: Generate checksum
      shell: powershell
      run: |
        $projectName = "${{ steps.plugin.outputs.projectName }}"
        $version = "${{ steps.plugin.outputs.version }}"
        $fileName = "$projectName-$version.dll"
        
        $checksum = (Get-FileHash $fileName -Algorithm SHA256).Hash
        echo "$checksum  $fileName" | Out-File -Encoding ASCII "CHECKSUM.txt"
        Write-Host "Checksum: $checksum"

    - name: Update manifest.json with plugin checksum
      shell: powershell
      run: |
        $pluginId = "${{ steps.plugin.outputs.pluginId }}"
        $version = "${{ steps.plugin.outputs.version }}"
        $projectName = "${{ steps.plugin.outputs.projectName }}"
        $dllFileName = "$projectName-$version.dll"
    
        # Carica manifest
        $manifest = Get-Content "manifest.json" | ConvertFrom-Json
    
        # Calcola checksum
        $checksum = (Get-FileHash $dllFileName -Algorithm SHA256).Hash
        $checksumWithPrefix = "sha256:$checksum"
    
        # Trova il plugin (documents o reports)
        $isDocument = $pluginId.StartsWith("document.")
        $targetArray = if ($isDocument) { $manifest.documents } else { $manifest.reports }
        $pluginEntry = $targetArray | Where-Object { $_.id -eq $pluginId }
    
        if ($null -eq $pluginEntry) {
            Write-Error "Plugin $pluginId not found in manifest.json"
            exit 1
        }
    
        # Aggiorna i campi
        $pluginEntry.checksum = $checksumWithPrefix
        $pluginEntry.releaseDate = (Get-Date -Format "yyyy-MM-dd")
        $pluginEntry.version = $version
    
        # Salva manifest aggiornato
        $manifest | ConvertTo-Json -Depth 10 | Set-Content "manifest.json" -Encoding UTF8
        Write-Host "Manifest aggiornato: $pluginId -> $checksumWithPrefix"

    - name: Commit and push manifest update
      shell: powershell
      run: |
        $pluginId = "${{ steps.plugin.outputs.pluginId }}"
        $version = "${{ steps.plugin.outputs.version }}"
    
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add manifest.json
        git commit -m "chore: Update manifest.json checksum for $pluginId v$version"
        git push origin master

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ${{ steps.plugin.outputs.projectName }}-${{ steps.plugin.outputs.version }}.dll
          CHECKSUM.txt
        body: |
          # Plugin: ${{ steps.plugin.outputs.projectName }}
          
          **Version**: ${{ steps.plugin.outputs.version }}
          
          ## Installation (In-App)
          
          1. Open **DO.VIVICARE UI**
          2. Go to **Tools → Plugin Manager**
          3. Find this plugin in **Available Plugins**
          4. Click **Download**
          5. Ready! (no restart needed)
          
          ## Manual Installation
          
          1. Download the `.dll` file
          2. Place in: `C:\Program Files\DO.VIVICARE\Plugins\`
          3. Restart the application
          
          ## Verify Integrity
          ```
          certutil -hashfile ${{ steps.plugin.outputs.projectName }}-${{ steps.plugin.outputs.version }}.dll SHA256
          ```
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
